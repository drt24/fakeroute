#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# fakeroute
#
# fakeroute intercept traceroute-like probes in order to simulate various
# topologies, including multipath due to per-flow load balancers.
#
# Authors: Jordan Augé       <jordan.auge@lip6.fr>
#          Marc-Olivier Buob <marc-olivier.buob@lip6.fr> 
#
# Copyright (C)2011-2013, UPMC Sorbonnes Universités / LIP6
#
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along with
# this program; see the file COPYING.  If not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
# TODO:
#
#  - improve Load Balancer support (configuration, per-packet and
#    per-destination load balancers)
#  - add the possibility to fuzz ICMP replies
#  - alternative dependency on Scapy ?
#

import dpkt, os, random, re, socket, sys, threading, zlib

#try:
#    from netfilterqueue import NetfilterQueue
#    HAS_NFQUEUE = True
#except:
import nfqueue
HAS_NFQUEUE = False

import dumbnet as dnet

# Import some useful regular expressions
from parserx import ipv4_rx, ipv4_simple_rx, ipv6_rx, ipv46_rx

# Directory in which fakeroute expects some network topologies
CONFIGPATH = ['./targets', '~/.fakeroute/targets', '/etc/fakeroute/targets']

ERR_NETFILTER = """
W: python-netfilter module not found.
You will need to add iptables rules manually so that incoming packets are sent to
the QUEUE target in order to be processed by this program.
"""

QUEUE_NUM_IPV4 = 1
QUEUE_NUM_IPV6 = 0

# Global variables needed in cb()
# - sock4  : IPv4 emission 
# - sock6  : IPv6 emission 
# - hopmap : network topologies emulated by fakeroute
sock4 = dnet.ip()
sock6 = dnet.ip()
hopmap = dict()

#-----------------------------------------------------------------
# Load configuration
#-----------------------------------------------------------------

def get_cfgpath():
    """
    \brief For each directory stored in CONFIGPATH, return the first
        existing directory. If no one exists, return None.
    \return The first valid configuration directory, None otherwise
    """
    for path in CONFIGPATH:
        if os.path.exists(path):
            return path
    return None

def sort_ip4_list(l):
    """
    \brief Sort a list of IPv4 address in the lexicographic order
    \param l The list to sort
    \return The corresponding sorted list
    """
    ll = [tuple(x.split('.')) for x in l]
    ll.sort()
    return ['.'.join(x) for x in ll]

def get_handled_files(cfgpath):
    """
    \brief Retrieve according to the filenames in 'cfgpath' the IPs
        handled by fakeroute.
    \param cfgpath The directory storing the network topology
        emulated by fakeroute.
    \return A pair made of two dictionnaries:
        handled4 { String: String } maps a target IPv4 with the filename it is issued
        handled6 { String: String } maps a target IPv6 with the filename it is issued
    """
    handled4, handled6 = ({}, {})
    filenames = os.listdir(cfgpath)
    for filename in filenames:
        if re.match("^%s-.*" % ipv4_rx, filename):
            handled4[filename.split('-')[0]] = os.path.join(cfgpath, filename)
        elif re.match("^%s-.*" % ipv6_rx, filename):
            handled6[filename.split('-')[0]] = os.path.join(cfgpath, filename)
        else:
            print "I: Ignored target file '%s'" % filename
    return (handled4, handled6)

def parse_file(dst_ip, filename, hopmap):
    """
    \brief Parse a fakeroute file in order to enrich hopmap.
    \param dst_ip The target IP captured by traceroute.
    \param hopmap The hopmap to enrich. You can pass an empty dictionnary.
        hopmap maps a target IP (captured by traceroute) with the corresponding
        emulated IP graph.
    """
    f = open(filename, 'r')
    succ = {}
    desc = None
    lines = f.readlines()
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if line[0] == '#':
            if "DESC" in line:
                desc = line[line.index("DESC") + 4:].strip()
            continue
        k, v = line.split()
        if k not in succ:
            succ[k] = [v]
        else:
            succ[k].append(v)
    print "   [ %32s ] %s" % (dst_ip, desc if desc else "(No description)")
    f.close()
    hopmap[dst_ip] = succ

def update_hopmap(handled, hopmap):
    """
    \brief Enrich hopmap according to handled
    \param handled A dictionnary {String: String} which maps for a target IP
        (captured by fakeroute) the corresponding filename containing the
        emulated topology.
    \param hopmap The hopmap to enrich. You can pass an empty dictionnary.
        hopmap maps a target IP (captured by traceroute) with the corresponding
        emulated IP graph.
    """
    for dst_ip, filename in handled.items():
        parse_file(dst_ip, filename, hopmap)


#-----------------------------------------------------------------
# NFQueue abstraction
#-----------------------------------------------------------------

def nfq_get_payload(packet):
    if HAS_NFQUEUE:
        return packet.get_payload()
    else:
        return packet.get_data()

def nfq_accept(packet):
    if HAS_NFQUEUE:
        packet.accept()
    else:
        packet.set_verdict(nfqueue.NF_ACCEPT)

def nfq_drop(packet):
    if HAS_NFQUEUE:
        packet.drop()
    else:
        packet.set_verdict(nfqueue.NF_DROP) # drop original packet

def queue_make(is_ipv6, callback):
    """
    \brief Create a queue binded to an appropriate socket.
    \param callback This function is called whenever this
        socket receives a packet/
    \param is_ipv6 Pass True iif this is an IPv6 queue, False
        iif this is an IPv4 queue
    \return The corresponding queue
    """
    queue_num = QUEUE_NUM_IPV6 if is_ipv6 else QUEUE_NUM_IPV4
    if HAS_NFQUEUE:
        queue = NetfilterQueue()
        queue.bind(queue_num, callback)
    else:
        queue = nfqueue.queue()
        queue.open()
        queue.bind(socket.AF_INET6 if is_ipv6 else socket.AF_INET)
        queue.set_callback(callback)
        queue.create_queue(queue_num)
    return queue

def queue_run(queue):
    """
    \brief Run queue
    \param queue to be run
    """
    if HAS_NFQUEUE:
        queue.run()
    else:
        queue.try_run()

def queue_close(queue, is_ipv6):
    """
    \brief Close queue
    \param queue The queue to be closed
    \param is_ipv6 Pass True iif this is an IPv6 queue, False
        iif this is an IPv4 queue
    """
    if HAS_NFQUEUE:
        queue.unbind()
    else:
        queue.unbind(socket.AF_INET6 if is_ipv6 else socket.AF_INET)
        queue.close()

#-----------------------------------------------------------------
# IPv4/IPv6 abstraction 
#-----------------------------------------------------------------

# IP layer 

def packet_is_ipv4(packet):
    return isinstance(packet, dpkt.ip.IP)

def packet_is_ipv6(packet):
    return isinstance(packet, dpkt.ip6.IP6)

def packet_get_ttl(packet):
    if packet_is_ipv4(packet): 
        return packet.ttl
    elif packet_is_ipv6(packet): 
        return packet.hlim
    else:
        raise ValueError("Invalid parameter (%r)" % packet)

def packet_set_ttl(packet, ttl):
    if packet_is_ipv4(packet): 
        packet.ttl = ttl
    elif packet_is_ipv6(packet): 
        packet.hlim = ttl
    else:
        raise ValueError("Invalid parameter (%r)" % packet)

def packet_get_src_ip(packet):
    return packet.src

def packet_get_dst_ip(packet):
    return packet.dst

# TODO sizeof(src_ip) to get rid off is_ipv6
def ip_to_str(ip, is_ipv6):
    if is_ipv6:
        return socket.inet_ntop(socket.AF_INET6, ip)
    else:
        return dnet.ip_ntoa(ip)

# TODO Use rx to get rid off is_ipv6 
def str_to_ip(ip, is_ipv6):
    if is_ipv6:
        return dnet.addr(ip).ip6,
    else:
        return dnet.addr(ip).ip,

# Metafield IP{4|6}/{TCP|UDP|ICMP} 

def packet_get_flow_id(packet):
    if packet_is_ipv4(packet): 
        if packet.p in [dpkt.ip.IP_PROTO_UDP, dpkt.ip.IP_PROTO_TCP]:
            return "%s%s%s%s%s" % (
                packet.src,
                packet.dst,
                packet.data.sport,
                packet.data.dport,
                packet.p
            )
        elif packet.p == dpkt.ip.IP_PROTO_ICMP:
            return "%s%s%s" % (
                packet.src,
                packet.dst,
                packet.p
            )
    elif packet_is_ipv6(packet): 
        return 0
    raise ValueError("Invalid parameter (%r)" % packet)

# TODO sizeof(src_ip) to get rid off is_ipv6
def make_icmp_reply(src_ip, dst_ip, ttl, icmp_data, icmp_type, icmp_code, is_ipv6):

    print "src_ip = %r\ndst_ip = %r\nttl = %r\nicmp_data = %r\nicmp_type = %r\nicmp_code = %r" % (
        src_ip, dst_ip, ttl, icmp_data, icmp_type, icmp_code
    )

    if is_ipv6:
        return dpkt.ip6.IP6(
            src  = src_ip, 
            dst  = dst_ip, 
            p    = dpkt.ip.IP_PROTO_ICMP6,
            hlim = ttl,
            #flags = dpkt.ip.IP_RF | dpkt.ip.IP_DF | dpkt.ip.IP_MF,
            #tos  = dpkt.ip.IP_TOS_PREC_INTERNETCONTROL,
            len  = 0,
            id   = random.randrange(0xFFFF),
            off  = 0,
            data = dpkt.icmp6.ICMP6(
                type = icmp_type,
                code = icmp_code,
                data = icmp_data
            )
        )
    else:
        return dpkt.ip.IP(
            src   = src_ip,
            dst   = dst_ip, 
            p     = dpkt.ip.IP_PROTO_ICMP,
            ttl   = ttl, 
            flags = dpkt.ip.IP_RF | dpkt.ip.IP_DF | dpkt.ip.IP_MF,
            tos   = dpkt.ip.IP_TOS_PREC_INTERNETCONTROL,
            len   = 0,
            id    = random.randrange(0xFFFF),
            off   = 0,
            data  = dpkt.icmp.ICMP(
                type = icmp_type,
                code = icmp_code,
                data = icmp_data
            )
        )

#-----------------------------------------------------------------
# Functions called when a packet is captured
#-----------------------------------------------------------------

#def cb(packet):
#    """
#    \brief This callback is call whenever a packet is captured by fakeroute
#    \param packet The captured packet
#    Note: this function uses the following global variables:
#        sock4  : The IPv4 socket managed by fakeroute
#        sock6  : The IPv6 socket managed by fakeroute
#        hopmap : Network topologies emulated by fakeroute
#    """
#    print "callback"
#    if HAS_NFQUEUE:
#        payload = packet.get_payload()
#    else:
#        payload = packet.get_data()
#
#    # How to better know the packet protocol
#    try: # IPv4
#        pkt = dpkt.ip.IP(payload)
#
#        # We accept all packets
#        if pkt.p != dpkt.ip.IP_PROTO_UDP or pkt.ttl > 20:
#            if HAS_NFQUEUE:
#                packet.accept()
#            else:
#                packet.set_verdict(nfqueue.NF_ACCEPT)
#            return 1
#
#        # Compute a flow id
#        if pkt.p == dpkt.ip.IP_PROTO_UDP:
#            flowid = "%s%s%s%s%s" % (pkt.src, pkt.dst, pkt.data.sport, pkt.data.dport, pkt.p)
#        elif pkt.p == dpkt.ip.IP_PROTO_TCP:
#            flowid = "%s%s%s%s%s" % (pkt.src, pkt.dst, pkt.data.sport, pkt.data.dport, pkt.p)
#        elif pkt.p == dpkt.ip.IP_PROTO_ICMP:
#            flowid = "%s%s%s" % (pkt.src, pkt.dst, pkt.p)
#
#        ttl = pkt.ttl
#        src = dnet.ip_ntoa(pkt.src)
#        dst = dnet.ip_ntoa(pkt.dst)
#        protocol = 4
#
#    except: # IPv6
#        pkt = dpkt.ip6.IP6(payload)
#        flowid = 0
#        ttl = pkt.hlim
#        src = socket.inet_ntop(socket.AF_INET6, pkt.src)
#        dst = socket.inet_ntop(socket.AF_INET6, pkt.dst)
#        protocol = 6
#
#    x = None
#    fakeip = 'start'
#    succ = hopmap[dst]
#    while ttl > 0:
#        fakeip = succ[fakeip]
#
#        if len(fakeip) == 1:
#            fakeip = fakeip[0]
#        else:
#            fakeip = fakeip[zlib.crc32(fakeip[0]+flowid) % len(fakeip)]
#            
#        if fakeip == 'end':
#            fakeip = dst
#            x = dpkt.icmp.ICMP.Unreach()
#            _type = dpkt.icmp.ICMP_UNREACH
#            _code = dpkt.icmp.ICMP_UNREACH_PORT
#            break
#        ttl -= 1
#
#    pkt.ttl = 1
#
#    # IP Header + First 8 Bytes of Original Datagram's Data
#    subip = str(pkt)[:(pkt.__hdr_len__+8)]
#
#    if not x:
#        x = dpkt.icmp.ICMP.TimeExceed()
#        _type = dpkt.icmp.ICMP_TIMEXCEED
#        _code = dpkt.icmp.ICMP_TIMEXCEED_INTRANS
#    
#    x.data = subip
#
#    if protocol == 4:
#        icmp = dpkt.icmp.ICMP(type = _type, code = _code, data = x)
#        ipout = dpkt.ip.IP(
#            src = dnet.addr(fakeip).ip,
#            dst = pkt.src,
#            p = dpkt.ip.IP_PROTO_ICMP,
#            ttl = dpkt.ip.IP_TTL_DEFAULT + 1 - pkt.ttl,
#            flags = dpkt.ip.IP_RF | dpkt.ip.IP_DF | dpkt.ip.IP_MF,
#            tos = dpkt.ip.IP_TOS_PREC_INTERNETCONTROL,
#            len = 0,
#            id = random.randrange(0xFFFF),
#            off = 0,
#            data = icmp
#        )
#
#        buf = dnet.ip_checksum(str(ipout))
#        sock4.send(buf)
#    else:
#        icmp = dpkt.icmp6.ICMP6(type = _type, code = _code, data = x)
#        ipout = dpkt.ip6.IP6(
#            src = dnet.addr(fakeip).ip6,
#            dst = pkt.src,
#            p = dpkt.ip.IP_PROTO_ICMP6,
#            hlim = dpkt.ip.IP_TTL_DEFAULT + 1 - ttl,
#            #flags = dpkt.ip.IP_RF | dpkt.ip.IP_DF | dpkt.ip.IP_MF,
#            #tos = dpkt.ip.IP_TOS_PREC_INTERNETCONTROL,
#            len = 0,
#            id = random.randrange(0xFFFF),
#            off = 0,
#            data = icmp
#        )
#
#        print "building fake answer %s -> %s" % (fakeip, src)
#        buf = dnet.ip_checksum(str(ipout))
#        sock6.send(buf)
#
#    if HAS_NFQUEUE:
#        packet.drop()
#    else:
#        packet.set_verdict(nfqueue.NF_DROP) # drop original packet
#    return 0

def make_reply(probe_packet):
    ttl = packet_get_ttl(probe_packet)
    assert ttl > 0
    is_ipv6 = packet_is_ipv6(probe_packet)

    flow_id = packet_get_flow_id(probe_packet)
    dst = ip_to_str(packet_get_dst_ip(probe_packet), is_ipv6)

    icmp_data = None
    fake_ip = "start"
    succ = hopmap[dst]
    while ttl > 0:
        fake_ip = succ[fake_ip]

        if len(fake_ip) == 1:
            print "1) fake_ip = %r" % fake_ip
            fake_ip = fake_ip[0]
        else:
            print "2) fake_ip = %r" % fake_ip
            # Several nodes for this TTL, emulate a per-flow load balancer
            fake_ip = fake_ip[zlib.crc32(fake_ip[0] + flow_id) % len(fake_ip)]
            
        if fake_ip == "end":
            fake_ip = dst
            if is_ipv6:
                icmp_data = dpkt.icmp.ICMP.Unreach()
                icmp_type = dpkt.icmp.ICMP_UNREACH      # 3 (destination unreachable)
                icmp_code = dpkt.icmp.ICMP_UNREACH_PORT # 3 (bad port) 
            else:
                icmp_data = dpkt.icmp6.ICMP.Unreach()
                icmp_type = dpkt.icmp6.ICMP_UNREACH     # 1 (destination unreachable)
                icmp_code = 4                           # 4 (port unreachable) (http://en.wikipedia.org/wiki/ICMPv6)
            break
        ttl -= 1

    # No ICMP packet crafted in the loop, so prepare a ICMP-TimeExceed packet
    if not icmp_data:
        if is_ipv6:
            icmp_data = dpkt.icmp.ICMP.TimeExceed()
            icmp_type = dpkt.icmp.ICMP_TIMEXCEED         # 11 (time exceed)
            icmp_code = dpkt.icmp.ICMP_TIMEXCEED_INTRANS # 0  (in transit)
        else:
            icmp_data = dpkt.icmp.ICMP.TimeExceed()
            icmp_type = dpkt.icmp6.ICMP_TIMEXCEED        # 3
            icmp_code = 0                                # 0 (hop limit exceeded in transit)
    
    # Craft ICMP data 
    # - Tweak the probe packet: it has been received witth TTL == 1
    # - Put IP Header + First 8 Bytes of Original Datagram's Data
    packet_set_ttl(probe_packet, 1)
    icmp_data.data = str(probe_packet)[:(probe_packet.__hdr_len__ + 8)] 

    print "-" * 80
    print "Building fake answer %s -> %s" % (
        fake_ip,
        ip_to_str(packet_get_src_ip(probe_packet), is_ipv6),
    )
    print "-" * 80

    print "icmp_code = %r icmp_type = %r" % (icmp_code, icmp_type)
    icmp_reply = make_icmp_reply(
        str_to_ip(fake_ip, is_ipv6),                               # src_ip
        packet_get_src_ip(probe_packet),                           # dst_ip
        dpkt.ip.IP_TTL_DEFAULT + 1 - packet_get_ttl(probe_packet), # ttl
        icmp_data,
        icmp_type,
        icmp_code,
        is_ipv6
    )

    return dnet.ip_checksum(str(icmp_reply))

def cb4(nfq_packet):
    """
    \brief This callback is call whenever a IPv4 packet is captured by fakeroute
    \param nfq_packet The captured packet
    Note: this function uses the following global variables:
        sock4  : The IPv4 socket managed by fakeroute
        hopmap : Network topologies emulated by fakeroute
    \return 1 if the packet is accepted (ttl <= 20)
            0 otherwise                 (ttl >  20)
    """
    print "callback IPv4"
    probe_packet = dpkt.ip.IP(nfq_get_payload(nfq_packet))

    # We accept all packets
    if probe_packet.p != dpkt.ip.IP_PROTO_UDP or probe_packet.ttl > 20:
        nfq_accept(packet)
        return 1

    probe_reply = make_reply(probe_packet)
    sock4.send(probe_reply)
    nfq_drop(nfq_packet)
    return 0

def cb6(nfq_packet):
    """
    \brief This callback is call whenever a IPv6 packet is captured by fakeroute
    \param nfq_packet The captured packet
    Note: this function uses the following global variables:
        sock6  : The IPv4 socket managed by fakeroute
        hopmap : Network topologies emulated by fakeroute
    \return 1 if the packet is accepted (ttl <= 20)
            0 otherwise                 (ttl >  20)
    """
    print "callback IPv6"
    probe_packet = dpkt.ip6.IP6(nfq_get_payload(nfq_packet))

    probe_reply = make_reply(probe_packet)
    sock6.send(probe_reply)
    nfq_drop(nfq_packet)
    return 0

class ThreadQueue(threading.Thread):
    def __init__(self, queue, is_ipv6):
        threading.Thread.__init__(self)
        self.queue = queue
        self.is_ipv6 = is_ipv6

    def run(self):
        print "Starting thread (is_ipv6 = %r) %r" % (self.is_ipv6, self.queue)
        queue_run(self.queue)

#-----------------------------------------------------------------
# Netfilter / iptables 
#-----------------------------------------------------------------

def check_netfilter():
    """
    \return True iif python-netfilter is properly installed
    """
    try:
        from netfilter.rule  import Rule, Target
        from netfilter.table import Table
        return True
    except ImportError:
        print "E: Missing package. Please install python-netfilter"
    except Exception, why:
        print why
    return False

def update_rules(ips, is_ipv6, rules):
    """
    \brief Enrich a list of iptable rules in order to capture the traffic sent
        toward a list of target IPs.
    \param is_ipv6 A boolean set to True iif ips only contains IPv6 addresses.
    \param ips The IPs to be captured. This set must contains either only IPv4
        or either IPv6
    \param rules The list of iptables rules  to enrich. You may pass an
        empty list.
    """
    from netfilter.rule  import Rule, Target
    from netfilter.table import Table

    table = Table("filter", auto_commit = False, ipv6 = is_ipv6)
    queue_num = QUEUE_NUM_IPV6 if is_ipv6 else QUEUE_NUM_IPV4
    for ip in ips:
        rule = Rule(
            destination = ip,
            jump = Target("NFQUEUE", "--queue-num %s" % queue_num)
        )
        rules.append(rule)
        table.append_rule("OUTPUT", rule)
    table.commit()

def delete_rules(rules, is_ipv6):
    """
    \brief Delete some rules from iptables
    \param rules A list of rules to remove
    \param is_ipv6 A boolean set to True iif ips only contains IPv6 addresses.
    \return True iif at least one rule has been removed
    """
    from netfilter.table import Table, IptablesError

    if not rules:
        return False

    print "I: Removing previously added ip%stables rules" % ('6' if is_ipv6 else '')
    table = Table("filter", ipv6 = is_ipv6)
    for rule in rules: 
        try:
            table.delete_rule("OUTPUT", rule)
        except IptablesError, why:
            # This rule has probably been removed manually...
            print why
            pass
    return True

#-----------------------------------------------------------------
# Main program
#-----------------------------------------------------------------

def main():
    # Configuration path
    cfgpath = get_cfgpath()

    # Check whether at least one directory storing network topologies exists
    if not cfgpath:
        print "E: No configuration directory found in %r" % CONFIGPATH
        sys.exit(-1)

    # List of handled IP addresses
    handled4, handled6 = get_handled_files(cfgpath)
    has_ipv4 = len(handled4) > 0
    has_ipv6 = len(handled6) > 0

    # With scapy we could fuzz some fields..
    print "I: Analyze target files..."
    if has_ipv4: update_hopmap(handled4, hopmap)
    if has_ipv6: update_hopmap(handled6, hopmap)
    has_ipv4 = False
    
    # IPTABLES
    rules4, rules6 = [], []

    if not check_netfilter():
        print ERR_NETFILTER 
        for ip4 in sorted(handled4.keys()):
            print "    iptables  -A OUTPUT -d %s -j QUEUE --queue-num %s" % (ip4, QUEUE_NUM_IPV4)
        for ip6 in sorted(handled6.keys()):
            print "    ip6tables -A OUTPUT -d %s -j QUEUE --queue-num %s" % (ip6, QUEUE_NUM_IPV6)
    else:
        # Adding iptables rules
        print "I: Adding iptables rules for handled destinations (see \"iptables --list\" and \"ip6tables --list\")"
        if has_ipv4: update_rules(handled4.keys(), False, rules4)
        if has_ipv6: update_rules(handled6.keys(), True,  rules6)

    print "I: Setting callback"
    if has_ipv4: q4 = queue_make(False, cb4)
    if has_ipv6: q6 = queue_make(True,  cb6)

    print "I: Running..."
    try:
        if has_ipv4: queue_run(q4)
        if has_ipv6: queue_run(q6)
#        if has_ipv4:
#            thread4 = ThreadQueue(q4, False)
#            thread4.setDaemon(True)
#            thread4.start()
#        if has_ipv6:
#            thread6 = ThreadQueue(q6, True)
#            thread6.setDaemon(True)
#            thread6.start()
    except KeyboardInterrupt:
        if has_ipv4:
#            thread4.join()
            queue_close(q4, False)
        if has_ipv6:
#            thread6.join()
            queue_close(q6, True)

    print ""
    print "I: Fakeroute terminated."

    # Removing IPTables rules
    if check_netfilter():
        if has_ipv4: delete_rules(rules4, False)
        if has_ipv6: delete_rules(rules6, True)
    else:
        print "W: Remember to remove any iptables rules you might have added."

if __name__ == "__main__":
    main()
