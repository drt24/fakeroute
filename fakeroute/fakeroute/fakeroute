#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# fakeroute
#
# fakeroute intercept traceroute-like probes in order to simulate various
# topologies, including multipath due to per-flow load balancers.
#
# Authors: Jordan Augé       <jordan.auge@lip6.fr>
#          Marc-Olivier Buob <marc-olivier.buob@lip6.fr> 
#
# Copyright (C)2011-2013, UPMC Sorbonnes Universités / LIP6
#
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along with
# this program; see the file COPYING.  If not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
# TODO:
#
#  - improve Load Balancer support (configuration, per-packet and
#    per-destination load balancers)
#  - add the possibility to fuzz ICMP replies
#  - alternative dependency on Scapy ?
#
IPV4 = True 

from dpkt.ip            import IP  #as dpkt_ip
from dpkt.icmp          import ICMP
from dpkt.ip6           import IP6 #   as dpkt_ip6
from dpkt.icmp6         import ICMP6
from pcs                import Chain
from pcs.packets.icmpv6 import icmpv6, ICMP6_TIME_EXCEEDED
from pcs.packets.ipv6   import ipv6

import dpkt, dumbnet, os, random, re, socket, sys, threading, zlib

try:
    from netfilterqueue import NetfilterQueue
    HAS_NFQUEUE = True
except:
    import nfqueue
    HAS_NFQUEUE = False

# TODO we could use inet_pton which raises an socket.error
# Import some useful regular expressions
from parserx import ipv4_rx, ipv4_simple_rx, ipv6_rx, ipv46_rx

#-----------------------------------------------------------------
# Constants
#-----------------------------------------------------------------

# Directory in which fakeroute expects some network topologies
CONFIGPATH = ['./targets', '~/.fakeroute/targets', '/etc/fakeroute/targets']

ERR_NETFILTER = """
W: python-netfilter module not found.
You will need to add iptables rules manually so that incoming packets are sent to
the QUEUE target in order to be processed by this program.
"""

QUEUE_NUM_IPV4 = 1
QUEUE_NUM_IPV6 = 0

#-----------------------------------------------------------------
# Global variables needed in cb()
#-----------------------------------------------------------------

# - sock4  : IPv4 emission 
# - sock6  : IPv6 emission 
# - hopmap : network topologies emulated by fakeroute

sock4 = socket.socket(socket.AF_INET,  socket.SOCK_RAW, socket.IPPROTO_RAW)
sock6 = socket.socket(socket.AF_INET6, socket.SOCK_RAW, socket.IPPROTO_RAW)
hopmap = dict()

#-----------------------------------------------------------------
# dpkt bug fix
#-----------------------------------------------------------------

import struct

#class IP(dpkt_ip):
#    def __str__(self):
#        print "COUCOU1", self.sum
#        if self.sum == 0:
#            self.sum = dpkt.in_cksum(self.pack_hdr() + self.opts)
#            print "COUCOU2", self.p
#            if (self.p == 6 or self.p == 17) and \
#               (self.off & (IP_MF|IP_OFFMASK)) == 0 and \
#               isinstance(self.data, dpkt.Packet) and self.data.sum == 0:
#                # Set zeroed TCP and UDP checksums for non-fragments.
#                p = str(self.data)                                                   # payload
#                s = dpkt.struct.pack('>4s4sxBH', self.src, self.dst, self.p, len(p)) # (src_ip, dst_ip, proto, len)
## <<
## In /usr/lib/pymodules/python2.7/dpkt/ip.py: 
#                s = dpkt.in_cksum_add(0, s)
#                s = dpkt.in_cksum_add(s, p)
#                print "CHECKSUM"
## --
## In https://code.google.com/p/dpkt/issues/detail?id=54
##                s = dpkt.in_cksum_add(0, s + p)
## >>
#                self.data.sum = dpkt.in_cksum_done(s)
#                if self.p == 17 and self.data.sum == 0:
#                    self.data.sum = 0xffff	# RFC 768
#                # XXX - skip transports which don't need the pseudoheader
#        return self.pack_hdr() + self.opts + str(self.data)
#
#
#class IP6(dpkt_ip6):
#    def __str__(self):
#        if (self.nxt == 6 or self.nxt == 17 or self.nxt == 58) and not self.data.sum:
#            p = str(self.data)
#            # XXX - set TCP, UDP, and ICMPv6 checksums
## <<
## In /usr/lib/pymodules/python2.7/dpkt/ip.py: 
##            s = dpkt.struct.pack('>16s16sxBH', self.src, self.dst, self.nxt, len(p))
##            s = dpkt.in_cksum_add(0, s)
##            s = dpkt.in_cksum_add(s, p)
## >>
#            # http://en.wikipedia.org/wiki/ICMPv6
#            # pseudo header (big endian >) = 128 bits (src_ip) + 128 bits (dst_ip) + 32 bits (ICMPv6 len) + 24 bits (set to 0) + 8 bits (next header)
#            print "-------------"
#            s = struct.pack(">16s16sii", self.src, self.dst, len(p), self.nxt)
#            s = dpkt.in_cksum_add(0, s)
#            s = dpkt.in_cksum_add(s, p)
#            print "-------------"
#            try:
#                self.data.sum = dpkt.in_cksum_done(s)
#                print "cksum = %x" % self.data.sum
#            except AttributeError:
#                pass
#        return dpkt.Packet.__str__(self)

#-----------------------------------------------------------------
# Load configuration
#-----------------------------------------------------------------

def get_cfgpath():
    """
    \brief For each directory stored in CONFIGPATH, return the first
        existing directory. If no one exists, return None.
    \return The first valid configuration directory, None otherwise
    """
    for path in CONFIGPATH:
        if os.path.exists(path):
            return path
    return None

def sort_ip4_list(l):
    """
    \brief Sort a list of IPv4 address in the lexicographic order
    \param l The list to sort
    \return The corresponding sorted list
    """
    ll = [tuple(x.split('.')) for x in l]
    ll.sort()
    return ['.'.join(x) for x in ll]

def get_handled_files(cfgpath):
    """
    \brief Retrieve according to the filenames in 'cfgpath' the IPs
        handled by fakeroute.
    \param cfgpath The directory storing the network topology
        emulated by fakeroute.
    \return A pair made of two dictionnaries:
        handled4 { String: String } maps a target IPv4 with the filename it is issued
        handled6 { String: String } maps a target IPv6 with the filename it is issued
    """
    handled4, handled6 = ({}, {})
    filenames = os.listdir(cfgpath)
    for filename in filenames:
        if re.match("^%s-.*" % ipv4_rx, filename):
            handled4[filename.split('-')[0]] = os.path.join(cfgpath, filename)
        elif re.match("^%s-.*" % ipv6_rx, filename):
            handled6[filename.split('-')[0]] = os.path.join(cfgpath, filename)
        else:
            print "I: Ignored target file '%s'" % filename
    return (handled4, handled6)

def parse_file(dst_ip, filename, hopmap):
    """
    \brief Parse a fakeroute file in order to enrich hopmap.
    \param dst_ip The target IP captured by traceroute.
    \param hopmap The hopmap to enrich. You can pass an empty dictionnary.
        hopmap maps a target IP (captured by traceroute) with the corresponding
        emulated IP graph.
    """
    f = open(filename, 'r')
    succ = {}
    desc = None
    lines = f.readlines()
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if line[0] == '#':
            if "DESC" in line:
                desc = line[line.index("DESC") + 4:].strip()
            continue
        k, v = line.split()
        if k not in succ:
            succ[k] = [v]
        else:
            succ[k].append(v)
    print "   [ %32s ] %s" % (dst_ip, desc if desc else "(No description)")
    f.close()
    hopmap[dst_ip] = succ

def update_hopmap(handled, hopmap):
    """
    \brief Enrich hopmap according to handled
    \param handled A dictionnary {String: String} which maps for a target IP
        (captured by fakeroute) the corresponding filename containing the
        emulated topology.
    \param hopmap The hopmap to enrich. You can pass an empty dictionnary.
        hopmap maps a target IP (captured by traceroute) with the corresponding
        emulated IP graph.
    """
    for dst_ip, filename in handled.items():
        parse_file(dst_ip, filename, hopmap)


#-----------------------------------------------------------------
# NFQueue abstraction
#-----------------------------------------------------------------

def nfq_get_payload(packet):
    if HAS_NFQUEUE:
        return packet.get_payload()
    else:
        return packet.get_data()

def nfq_accept(packet):
    if HAS_NFQUEUE:
        packet.accept()
    else:
        packet.set_verdict(nfqueue.NF_ACCEPT)

def nfq_drop(packet):
    if HAS_NFQUEUE:
        packet.drop()
    else:
        packet.set_verdict(nfqueue.NF_DROP) # drop original packet

def queue_make(is_ipv6, callback):
    """
    \brief Create a queue binded to an appropriate socket.
    \param callback This function is called whenever this
        socket receives a packet/
    \param is_ipv6 Pass True iif this is an IPv6 queue, False
        iif this is an IPv4 queue
    \return The corresponding queue
    """
    queue_num = QUEUE_NUM_IPV6 if is_ipv6 else QUEUE_NUM_IPV4
    if HAS_NFQUEUE:
        queue = NetfilterQueue()
        queue.bind(queue_num, callback)
    else:
        queue = nfqueue.queue()
        queue.open()
        queue.bind(socket.AF_INET6 if is_ipv6 else socket.AF_INET)
        queue.set_callback(callback)
        queue.create_queue(queue_num)
    return queue

def queue_run(queue):
    """
    \brief Run queue
    \param queue to be run
    """
    if HAS_NFQUEUE:
        queue.run()
    else:
        queue.try_run()

def queue_close(queue, is_ipv6):
    """
    \brief Close queue
    \param queue The queue to be closed
    \param is_ipv6 Pass True iif this is an IPv6 queue, False
        iif this is an IPv4 queue
    """
    if HAS_NFQUEUE:
        queue.unbind()
    else:
        queue.unbind(socket.AF_INET6 if is_ipv6 else socket.AF_INET)
        queue.close()

#-----------------------------------------------------------------
# IPv4/IPv6 abstraction 
#-----------------------------------------------------------------

# IP layer 

def packet_is_ipv4(packet):
    return isinstance(packet, IP)

def packet_is_ipv6(packet):
    return isinstance(packet, IP6)

def packet_get_ttl(packet):
    if packet_is_ipv4(packet): 
        return packet.ttl
    elif packet_is_ipv6(packet): 
        return packet.hlim
    else:
        raise ValueError("Invalid parameter (%r)" % packet)

def packet_set_ttl(packet, ttl):
    if packet_is_ipv4(packet): 
        packet.ttl = ttl
    elif packet_is_ipv6(packet): 
        packet.hlim = ttl
    else:
        raise ValueError("Invalid parameter (%r)" % packet)

def packet_get_src_ip(packet):
    """
    \return Source IP of the packet (binary)
    """
    return packet.src

def packet_get_dst_ip(packet):
    """
    \return Destination IP of the IP packet (binary)
    """
    return packet.dst

def ip_get_version(ip):
    """
    \brief Guess the IP version of a given ip
    \param ip An IP address
    \return 4 if ip is an IPv4, 6 if ip is an IPv6
    """
    size_ip = len(str(ip))
    if size_ip == 16:  # IPv6
        return 6
    elif size_ip == 4: # IPv4
        return 4
    else:
        raise ValueError("Invalid IP (%r) (size = %r)" % (ip, size_ip))

def ip_to_str(ip):
    """
    \param ip An IP address (binary)
    \return The human-readable string related to an IP
    """
    ip_version = ip_get_version(ip)
    if ip_version == 6: 
        return socket.inet_ntop(socket.AF_INET6, ip)
    elif ip_version == 4:
        return socket.inet_ntop(socket.AF_INET, ip) 
    else:
        raise ValueError("Invalid IP (%r) (size = %r)" % (ip, size_ip))

def str_to_ip(ip):
    """
    \param ip An IP address (human readable string)
    \return The corresponding IP address (binary) 
    """
    if re.match("^%s$" % ipv6_rx, ip): 
        return socket.inet_pton(socket.AF_INET6, ip) 
    elif re.match("^%s$" % ipv4_rx, ip):
        return socket.inet_pton(socket.AF_INET, ip) 
    else:
        raise ValueError("Invalid IP (%r) (size = %r)" % (ip, size_ip))

# Metafield IP{4|6}/{TCP|UDP|ICMP} 

def packet_get_flow_id(packet):
    """
    \param packet An IP packet (either IPv4 or either IPv6)
    \return The flow-id related to an IP packet
    """
    if packet_is_ipv4(packet): 
        if packet.p in [dpkt.ip.IP_PROTO_UDP, dpkt.ip.IP_PROTO_TCP]:
            return "%s%s%s%s%s" % (
                packet.src,
                packet.dst,
                packet.data.sport,
                packet.data.dport,
                packet.p
            )
        elif packet.p == dpkt.ip.IP_PROTO_ICMP:
            return "%s%s%s" % (
                packet.src,
                packet.dst,
                packet.p
            )
    elif packet_is_ipv6(packet): 
        return 0
    raise ValueError("Invalid parameter (%r)" % packet)

def make_icmp_reply(src_ip, dst_ip, ttl, icmp_data, icmp_type, icmp_code):
    ip_version = ip_get_version(src_ip)

    if ip_version == 6:

        icmp = ICMP6(
            type = icmp_type,
            code = icmp_code,
            data = icmp_data,
            sum = 0x2547
        )

        # http://en.wikipedia.org/wiki/IPv6_header#Fixed_header
        return IP6(
            src  = src_ip, 
            dst  = dst_ip, 
            nxt  = dpkt.ip.IP_PROTO_ICMP6,
            hlim = ttl,
            plen = len(icmp),
            id   = random.randrange(0xFFFF), # ?
            off  = 0,                        # ?
            data = icmp
        )

    elif ip_version == 4:
        icmp = ICMP(
            type = icmp_type,
            code = icmp_code,
            data = icmp_data
        )

        # http://en.wikipedia.org/wiki/IPv4_header#Header
        return IP(
            src   = src_ip,
            dst   = dst_ip, 
            p     = dpkt.ip.IP_PROTO_ICMP,
            ttl   = ttl,
#            flags = dpkt.ip.IP_RF | dpkt.ip.IP_DF | dpkt.ip.IP_MF, #  | Don't fragment |
#            tos   = dpkt.ip.IP_TOS_PREC_INTERNETCONTROL,           # ?
            len   = len(icmp),
#            id    = random.randrange(0xFFFF),                      # ?
#            off   = 0,                                             # ?
            data  = icmp 
        )

    else:
        raise ValueError("Unknown IP version")

#-----------------------------------------------------------------
# Functions called when a packet is captured
#-----------------------------------------------------------------

def make_reply(probe_packet):
    ttl = packet_get_ttl(probe_packet)
    assert ttl > 0
    is_ipv6 = packet_is_ipv6(probe_packet)

    flow_id = packet_get_flow_id(probe_packet)
    dst = ip_to_str(packet_get_dst_ip(probe_packet))

    icmp_data = None
    fake_ip = "start"
    succ = hopmap[dst]
    while ttl > 0:
        fake_ip = succ[fake_ip]

        if len(fake_ip) == 1:
            fake_ip = fake_ip[0]
        else:
            # Several nodes for this TTL, emulate a per-flow load balancer
            fake_ip = fake_ip[zlib.crc32(fake_ip[0] + flow_id) % len(fake_ip)]
            
        if fake_ip == "end":
            fake_ip = dst
            if is_ipv6:
                icmp_data = ICMP6.Unreach()
                icmp_type = dpkt.icmp6.ICMP6_DST_UNREACH # 1 (destination unreachable)
                icmp_code = 4                            # 4 (port unreachable) (http://en.wikipedia.org/wiki/ICMPv6)
            else:
                # http://www.networksorcery.com/enp/protocol/icmp/msg3.htm
                icmp_data = ICMP.Unreach()
                icmp_type = dpkt.icmp.ICMP_UNREACH       # 3 (destination unreachable)
                icmp_code = dpkt.icmp.ICMP_UNREACH_PORT  # 3 (bad port) 
            break
        ttl -= 1

    # No ICMP packet crafted in the loop, so prepare a ICMP-TimeExceed packet
    if not icmp_data:
        if is_ipv6:
            icmp_data = ICMP6.TimeExceed()
            icmp_type = dpkt.icmp6.ICMP6_TIME_EXCEEDED   # 3
            icmp_code = 0                                # 0 (hop limit exceeded in transit)
        else:
            # TODO Wrong checksum
            icmp_data = ICMP.TimeExceed()
            icmp_type = dpkt.icmp.ICMP_TIMEXCEED         # 11 (time exceed)
            icmp_code = dpkt.icmp.ICMP_TIMEXCEED_INTRANS # 0  (in transit)
    
    # Craft ICMP data (common to ICMP unreach and time exceed) 
    # - Tweak the probe packet: it has been received with TTL == 1
    packet_set_ttl(probe_packet, 1) # ?

    if is_ipv6:
        # http://www.ietf.org/rfc/rfc2463.txt
        # In data: As much of invoking packet as will fit without the ICMPv6 packet
        # exceeding the minimum IPv6 MTU [IPv6]
        icmp_data.data = str(probe_packet)[:1280]
        icmp_data.data = str(probe_packet)[:]
    else:
        # - Put IP Header + first 8 bytes of Original Datagram's Data
        # http://www.networksorcery.com/enp/protocol/icmp/msg11.htm
        icmp_data.data = str(probe_packet)[:(probe_packet.__hdr_len__ + 8)] 

    print "-" * 80
    print "Building fake answer %s -> %s" % (
        fake_ip,
        ip_to_str(packet_get_src_ip(probe_packet)),
    )
    print "-" * 80
    
    icmp_reply = make_icmp_reply(
        str_to_ip(fake_ip),                                        # src_ip
        packet_get_src_ip(probe_packet),                           # dst_ip
        dpkt.ip.IP_TTL_DEFAULT + 1 - packet_get_ttl(probe_packet), # ttl
        icmp_data,
        icmp_type,
        icmp_code
    )

    return str(icmp_reply)

def cb4(probe_packet_bin):
    """
    \brief This callback is call whenever a IPv4 packet is captured by fakeroute
    \param probe_packet_bin The captured packet
    Note: this function uses the following global variables:
        sock4  : The IPv4 socket managed by fakeroute
        hopmap : Network topologies emulated by fakeroute
    \return 1 if the packet is dropped
            0 otherwise
    """
    print "callback IPv4"
    probe_packet = IP(nfq_get_payload(probe_packet_bin))
    probe_reply_bin = make_reply(probe_packet)
    sock4.sendto(probe_reply_bin, ("127.0.0.1", 0))
    nfq_drop(probe_packet_bin)
    return 0

def cb6(probe_packet_bin):
    """
    \brief This callback is call whenever a IPv6 packet is captured by fakeroute
    \param probe_packet_bin The captured packet
    Note: this function uses the following global variables:
        sock6  : The IPv4 socket managed by fakeroute
        hopmap : Network topologies emulated by fakeroute
    \return 1 if the packet is dropped
            0 otherwise
    """
    print "callback IPv6"
    probe_packet = IP6(nfq_get_payload(probe_packet_bin))
    probe_reply_bin = make_reply(probe_packet)
    sock6.sendto(probe_reply_bin, ("::1", 0))
    nfq_drop(probe_packet_bin)
    return 0

#-----------------------------------------------------------------
# Netfilter / iptables 
#-----------------------------------------------------------------

def check_netfilter():
    """
    \return True iif python-netfilter is properly installed
    """
    try:
        from netfilter.rule  import Rule, Target
        from netfilter.table import Table
        return True
    except ImportError:
        print "E: Missing package. Please install python-netfilter"
    except Exception, why:
        print why
    return False

def update_rules(ips, is_ipv6, rules):
    """
    \brief Enrich a list of iptable rules in order to capture the traffic sent
        toward a list of target IPs.
    \param is_ipv6 A boolean set to True iif ips only contains IPv6 addresses.
    \param ips The IPs to be captured. This set must contains either only IPv4
        or either IPv6
    \param rules The list of iptables rules  to enrich. You may pass an
        empty list.
    """
    from netfilter.rule  import Rule, Target
    from netfilter.table import Table

    table = Table("filter", auto_commit = False, ipv6 = is_ipv6)
    queue_num = QUEUE_NUM_IPV6 if is_ipv6 else QUEUE_NUM_IPV4
    for ip in ips:
        rule = Rule(
            destination = ip,
            jump = Target("NFQUEUE", "--queue-num %s" % queue_num)
        )
        rules.append(rule)
        table.append_rule("OUTPUT", rule)
    table.commit()

def delete_rules(rules, is_ipv6):
    """
    \brief Delete some rules from iptables
    \param rules A list of rules to remove
    \param is_ipv6 A boolean set to True iif ips only contains IPv6 addresses.
    \return True iif at least one rule has been removed
    """
    from netfilter.table import Table, IptablesError

    if not rules:
        return False

    print "I: Removing previously added ip%stables rules" % ('6' if is_ipv6 else '')
    table = Table("filter", ipv6 = is_ipv6)
    for rule in rules: 
        try:
            table.delete_rule("OUTPUT", rule)
        except IptablesError, why:
            # This rule has probably been removed manually...
            print why
            pass
    return True

#-----------------------------------------------------------------
# Main program
#-----------------------------------------------------------------

def main():

    # Configuration path
    cfgpath = get_cfgpath()

    # Check whether at least one directory storing network topologies exists
    if not cfgpath:
        print "E: No configuration directory found in %r" % CONFIGPATH
        sys.exit(-1)

    # List of handled IP addresses
    handled4, handled6 = get_handled_files(cfgpath)
#    has_ipv4 = len(handled4) > 0
#    has_ipv6 = len(handled6) > 0
    has_ipv4 = IPV4
    has_ipv6 = not has_ipv4

    # With scapy we could fuzz some fields..
    print "I: Analyze target files..."
    if has_ipv4: update_hopmap(handled4, hopmap)
    if has_ipv6: update_hopmap(handled6, hopmap)
    
    # IPTABLES
    rules4, rules6 = [], []

    if not check_netfilter():
        print ERR_NETFILTER 
        for ip4 in sorted(handled4.keys()):
            print "    iptables  -A OUTPUT -d %s -j QUEUE --queue-num %s" % (ip4, QUEUE_NUM_IPV4)
        for ip6 in sorted(handled6.keys()):
            print "    ip6tables -A OUTPUT -d %s -j QUEUE --queue-num %s" % (ip6, QUEUE_NUM_IPV6)
    else:
        # Adding iptables rules
        print "I: Adding iptables rules for handled destinations (see \"iptables --list\" and \"ip6tables --list\")"
        if has_ipv4: update_rules(handled4.keys(), False, rules4)
        if has_ipv6: update_rules(handled6.keys(), True,  rules6)

    print "I: Setting callback"
    if has_ipv4: q4 = queue_make(False, cb4)
    if has_ipv6: q6 = queue_make(True,  cb6)

    print "I: Running..."
    try:
        if has_ipv4: queue_run(q4)
        if has_ipv6: queue_run(q6)
    except KeyboardInterrupt:
        if has_ipv4:
            queue_close(q4, False)
        if has_ipv6:
            queue_close(q6, True)

    print ""
    print "I: Fakeroute terminated."

    # Removing IPTables rules
    if check_netfilter():
        if has_ipv4: delete_rules(rules4, False)
        if has_ipv6: delete_rules(rules6, True)
    else:
        print "W: Remember to remove any iptables rules you might have added."

if __name__ == "__main__":
    main()
